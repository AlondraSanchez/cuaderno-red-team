---
title: Pivoting
modulo: M7 - Movimientos laterales
fecha: 2025-07-31
layout: apunte
slug: 2025-07-31-pivoting
vm: https://drive.google.com/drive/folders/10MdL2c8EpwijxsweVVdln4J5d1KG9v9v
---
# üêáPivoting
>[!abstract] Definici√≥n:
>**Pivoting** es el proceso de usar una m√°quina comprometida como trampol√≠n para acceder a otras m√°quinas en la red que ser√≠an inaccesibles directamente desde la m√°quina atacante.

# üíªPr√°ctica
**Pre√°mbulo**
Para esta pr√°ctica, partimos de las siguientes m√°quinas:
- **Pivoting VM** (Credenciales ubuntu/ubuntu)
- **Pivoting VM 2**

La idea es simular un entorno como el siguiente

![[escenario_pivoting.png]]

Donde **Pivoting VM** est√° conectada a las redes *VLAN20* y *VLAN30*, mientras que **Pivoting VM 2** est√° conectada a las redes *VLAN30* y *VLAN40*. Esto significa que hay comunicaci√≥n entre ambas m√°quinas mediante *VLAN30*.

Y, el contexto es que, por -*inserte cualquier raz√≥n*-, la **Kali** consigui√≥ infiltrarse en *VLAN20* y vulnerar la m√°quina **Pivoting VM**. Ahora lo que queremos es "saltar" o "pivotar" hacia la **Pivoting VM 2**

Entonces, configuramos las siguientes redes:
- **VLAN20** con m√°scara de subred 10.0.20.0/24
- **VLAN30** con m√°scara de subred 10.0.30.0/24
- **VLAN40** con m√°scara de subred 10.0.40.0/24

Y configuramos ambas m√°quinas:
- **Pivoting VM** 
	- **Adaptador 1:** Red NAT ‚Üí *VLAN20*
	- **Adaptador 2:** Red NAT ‚Üí *VLAN30*
- **Pivoting VM 2**
	- **Adaptador 1:** Red NAT ‚Üí *VLAN30*
	- **Adaptador 2:** Red NAT ‚Üí *VLAN40*

La idea es conectarnos a la **Pivoting VM** y de ah√≠ saltar a la **Pivoting VM 2**, entonces la **Kali** tambi√©n deber√° estar conectada a la *VLAN20*

![[diagrama_clase_pivoting.png]]

Los comandos clave que construiremos son los siguientes
```bash
ssh <user>@Ip_proxy -p X -L (IpKali):PuertoLocal:IpRemota:22
ssh <user>@Ip_proxy -p X -R IpPivoting1:PuertoPiv1:IpLocal:4444
```

**üí™ MANOS A LA OBRA**

>[!warning] Importante!!:
>Durante esta pr√°ctica se lanzar√°n comandos desde terminales distintas (todas alojadas en la **Kali**). Por favor leer los comentarios adjuntos en cada comando para saber en qu√© terminal deben ir.

## üîéEtapa 1: Reconocimiento de Pivoting VM

Con las 3 m√°quinas configuradas, encendidas y funcionando, hacemos un **escaneo de red desde la terminal Kali**
```bash
#Este comando se ejecuta en la terminal llamada Kali
sudo arp-scan -l -I eth0
```

**En mi caso**, la IP para la m√°quina **Pivoting VM en la red *VLAN20*** es la `10.0.20.5`. 

Una vez conocida la IP, nos conectamos mediante ssh **desde la terminal SSH Piv1**
```bash
#Este comando se ejecuta en la terminal llamada SSH Piv1
ssh ubuntu@10.0.20.5
```

Dentro de la m√°quina, nos interesa ver si est√° conectada a otras redes, as√≠ que ejecutamos el comando `ip a` para ver el estado de la red de **Pivoting VM**. En mi caso, la m√°quina tiene asignada la IP `10.0.30.4` para la *VLAN30*.

![[pivoting_ip_pivoting_vm.png]]


## ‚öôÔ∏èEtapa 2: Configuraci√≥n de t√∫nel

Recordemos que la **Kali** no tiene acceso directo a *VLAN30*, pero **Pivoting VM** s√≠. As√≠ que el siguiente paso es crear un **t√∫nel o proxy** que redirija el tr√°fico desde la **Kali** hacia *VLAN30* a trav√©s de **Pivoting VM**. 

De esta manera podremos lanzar comandos desde la **Kali** pero que vayan a nombre de **Pivoting VM**. Esto ser√° √∫til para **escanear la red *VLAN30***.

En primer lugar, ejecutamos el comando:
```bash
#Este comando se ejecuta en la terminal llamada "-D 9050"
ssh -D 9050 ubuntu@10.0.20.5
```

Esto crea un **SOCKS proxy** en la m√°quina atacante, escuchando en el puerto `9050`.

>[!question] ¬øQu√© es un SOCKS proxy?:
>Un **SOCKS proxy** es una especie de "t√∫nel universal" que permite enrutar _cualquier tipo de tr√°fico_ (TCP y a veces UDP) a trav√©s de una m√°quina intermedia. Es como decirle a las herramientas:
> >"En vez de conectarte directamente al objetivo, pasa por esta m√°quina de confianza (Pivoting VM) y que _ella_ hable con el objetivo por ti."

Esto significa que, todo lo que se configure para que use `localhost:9050` como proxy... se enviar√° a trav√©s de **Pivoting VM**.

Lo siguiente, entonces, es configurar el **proxy de la Kali**, y para ello utilizamos `proxychains`.

En primer lugar, buscamos el archivo de configuraci√≥n del `proxychains` que nos aplique.
```bash
#Este comando se lanza desde la terminal llamada Kali
ls -la /etc | grep proxychain
```

En mi caso, el archivo es `proxychains4.conf` ‚Üí Consultamos este archivo con `cat` o, editamos directamente con `sudo nano` (es importante lanzarlo con `sudo` para que los cambios se guarden).

**¬øQu√© debemos tener en el archivo?** ‚Üí Las siguientes l√≠neas deben estar **descomentadas** (que no aparezca el s√≠mbolo `#` al principio). Y en la *ProxyList* debe decir *socks5* y apuntar al puerto que abrimos anteriormente.
```
dynamic_chain
proxy_dns
tcp_read_time_out 15000
tcp_connect_time_out 8000

[ProxyList]
socks5 127.0.0.1 9050
```

**Escaneamos la red *VLAN30* desde la Kali:**
```bash
#Este comando se lanza desde la terminal llamada Kali
proxychains nmap 10.0.30.3-20 -p 22 -sV
```

La salida de este comando deber√≠a verse m√°s o menos as√≠:
>...
>
>[proxychains] Dynamic chain ... 127.0.0.1:9050 ... 10.0.30.4:80 <--- socket error or timeout!
>
>[proxychains] Dynamic chain ... 127.0.0.1:9050 ... 10.0.30.7:80 <--- socket error or timeout!
>
>[proxychains] Dynamic chain ... 127.0.0.1:9050 ... 10.0.30.10:80 ... OK
>
>[proxychains] Dynamic chain ... 127.0.0.1:9050 ... 10.0.30.11:80 ... OK
>
>...

**SI NO ES EL CASO...**

Hay alternativas:
1. Utilizar otra versi√≥n de Kali (preferentemente [la m√°quina compartida en clase](https://drive.google.com/drive/folders/1_sv45Jutib_3Gmp228vTHdC2vdI5UayD)), y empezar desde cero el ejercicio.
2. Cambiar la versi√≥n de `nmap` a otra m√°s antigua que sea compatible con `proxychains`.
3. **Usar un script que nos devuelva lo que buscamos**.

>[!note] Nota:
>Esta etapa (configuraci√≥n de t√∫nel) es necesaria en este ejercicio porque **no conocemos la IP de Pivoting VM 2 en la *VLAN30***. 
>Si no fuera el caso, los pasos relacionados con `proxychains` son, en esencia, opcionales, y podr√≠amos pasar directamente a la etapa de **Pivoting**, a menos que quisi√©ramos ejecutar otros comandos a nombre de **Pivoting VM**.

Por lo anterior, lo m√°s f√°cil es crear un script **en la Kali** que nos diga **cu√°l es la IP de la Pivoting VM 2**. En mi caso lo llam√© `script_proxychains.sh` y contiene el siguiente c√≥digo:
```bash
#!/bin/bash

# Red que se quiere escanear
RED="10.0.30"

# Rango de hosts donde podr√≠a estar Pivoting VM 2
INICIO=3
FIN=20

# Puertos abiertos que se buscan
PUERTOS=(22 80)

# En este archivo se escriben las IPs encontradas
SALIDA="ips_abiertas.txt"
> "$SALIDA"  # Vac√≠a el archivo antes de empezar

echo "[*] Escaneando IPs con puertos abiertos..."
echo "[!] Pulsa 'q' en cualquier momento para detener la ejecuci√≥n."

for host in $(seq $INICIO $FIN); do
  IP="$RED.$host"

  # Verifica si el usuario ha pulsado 'q'
  read -t 1 -n 1 key
  if [[ $key = "q" ]]; then
    echo "[!] Escaneo cancelado por el usuario."
    break
  fi

  for port in "${PUERTOS[@]}"; do
    if proxychains timeout 3 bash -c "echo > /dev/tcp/$IP/$port" 2>/dev/null; then
      echo "$IP tiene el puerto $port abierto"
      echo "$IP:$port" >> "$SALIDA"
    else
      echo "$IP puerto $port cerrado o sin respuesta"
    fi
  done
done

echo "[+] IPs con puertos abiertos guardadas en: $SALIDA"
```

Este script automatiza la detecci√≥n de **hosts activos** en una red interna (oculta tras pivoting), comprobando si tienen **puertos espec√≠ficos abiertos** (como 22 u 80) realizando intentos de conexi√≥n utilizando `/dev/tcp/<IP>/<puerto>`, que es una funcionalidad interna de bash que intenta abrir una conexi√≥n TCP. Adem√°s, utiliza `proxychains` para enrutar el tr√°fico a trav√©s de un t√∫nel SOCKS previamente establecido (en este caso, mediante `ssh -D`).

Una vez creado el script, le damos permisos de ejecuci√≥n y lo ejecutamos
```bash
# Estos comandos se lanzan en la terminal llamada "Kali"
chmod +x script_proxychains.sh
./script_proxychains.sh
```

Ahora solo queda esperar a que detecte la IP de **Pivoting VM 2**. En mi caso, la IP es `10.0.30.5`

>[!warning] Importante:
>Este script tambi√©n nos mostrar√° la IP de **Pivoting VM** en la *VLAN30*, por lo cual hay que tenerlas bien identificadas.

Una vez que logramos el objetivo, podemos cerrar la terminal llamada "-D 9050"

## ü¶òEtapa 3: Pivoting
Ahora que conocemos la IP de **Pivoting VM 2**, podemos establecer un **t√∫nel ssh con port forwarding** utilizando el siguiente comando:
```bash
#Este comando se lanza desde la terminal llamada "-L PIV2"
ssh ubuntu@10.0.20.5 -L 2222:10.0.30.5:22
```
üîπ **Donde:**
- El flag `-L` es de **port forwarding local**, y su sintaxis general es:
	- `-L [puerto_local]:[IP_objetivo_visible_para_el_host_remoto]:[puerto_objetivo]`

En este caso:

| Parte       | Significado                                               |     |
| ----------- | --------------------------------------------------------- | --- |
| `2222`      | Puerto en la **Kali** que se abrir√° como punto de entrada |     |
| `10.0.30.5` | IP objetivo, accesible desde **Pivoting VM**              |     |
| `22`        | Puerto SSH de **Pivoting VM 2**                           |     |

**¬øQu√© hace este comando?** ‚Üí Abre un puerto local (2222) que se conecta _desde Pivoting VM_ a _Pivoting VM 2_ por su puerto 22. 

En otras palabras, el comando da la siguiente instrucci√≥n:

>Con√©ctate por SSH a la m√°quina `10.0.20.5` (Pivoting1), y desde all√≠ crea un t√∫nel que me permita acceder **desde mi Kali (localhost)** al puerto **22 de Pivoting VM 2** (`10.0.30.5`) como si lo tuviera aqu√≠ mismo, en el puerto **2222**

**¬øQu√© conseguimos con esto?** ‚Üí Exponer el servicio SSH de **Pivoting VM 2** (que solo es accesible desde **Pivoting VM**) en la m√°quina **Kali**, en el puerto 2222.

Este paso nos permite pasar al siguiente comando: **Conectar por ssh a la m√°quina Pivoting VM 2**
```bash
#Este comando se ejecuta en una nueva terminal llamada "SSH PIV2"
ssh usuario@localhost -p 2222
```

